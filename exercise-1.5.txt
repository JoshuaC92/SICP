Consider the following expression:

(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
(test 0 (p))


How would this behave if it was evaluated using Applicative order?

When the test function is called each sub expression is then evaluated BEFORE being passed into the function, as per applicative order rules. This would result in an infinite loop as the expression (p) recurse's to itself. Somthing like:

(test 0 (p (p (p (p (p 0 ......)))))).....etc forever..........


How would this behave if it was evaluated using Normal order?

As in normal order the expressions are fully expanded  before they are evaluated and then only evaluated as needed the call to test would return its result before having to evaluate the value of (p). Somthing like:

(test 0 (p)) -> (if (= 0 0) 0 (p)) -> (if (= 0 0) 0 (p)) -> (if #t 0 (p)) -> 0
